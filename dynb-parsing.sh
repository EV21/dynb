#!/bin/bash

# Created by argbash-init v2.10.0
# Rearrange the order of options below according to what you would like to see in the help message.
# ARG_OPTIONAL_BOOLEAN([version],[v],[outputs the client version],[off])
# ARG_OPTIONAL_BOOLEAN([link],[l],[links to your script at ~/.local/bin/dynb],[off])
# ARG_OPTIONAL_BOOLEAN([reset],[r],[deletes the client blocking status file],[off])
# ARG_OPTIONAL_BOOLEAN([debug],[],[enables debug mode],[off])
# ARG_OPTIONAL_SINGLE([update-method],[m],[choose if you want to use DynDNS2 or the DomRobot RPC-API],[])
# ARG_OPTIONAL_SINGLE([ip-mode],[i],[updates type A (IPv4) and AAAA (IPv6) records],[])
# ARG_OPTIONAL_SINGLE([domain],[d],[set the domain you want to update],[])
# ARG_OPTIONAL_SINGLE([service-provider],[s],[set your provider in case you are using DynDNS2],[])
# ARG_OPTIONAL_SINGLE([username],[u],[depends on your selected update method and your provider],[])
# ARG_OPTIONAL_SINGLE([password],[p],[depends on your selected update method and your provider],[])
# ARG_OPTIONAL_SINGLE([token],[t],[depends on your selected update method and your provider],[])
# ARG_OPTIONAL_SINGLE([interval],[],[choose the seconds interval to run the script in a loop, minimum is 60],[])
# ARG_HELP([DynB - dynamic DNS update script for bash])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.10.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info


# # When called, the process ends.
# Args:
# 	$1: The exit message (print to stderr)
# 	$2: The exit code (default is 1)
# if env var _PRINT_HELP is set to 'yes', the usage is print to stderr (prior to $1)
# Example:
# 	test -f "$_arg_infile" || _PRINT_HELP=yes die "Can't continue, have to supply file as an argument, got '$_arg_infile'" 4
die()
{
	local _ret="${2:-1}"
	test "${_PRINT_HELP:-no}" = yes && print_help >&2
	echo "$1" >&2
	exit "${_ret}"
}


# Function that evaluates whether a value passed to it begins by a character
# that is a short option of an argument the script knows about.
# This is required in order to support getopts-like short options grouping.
begins_with_short_option()
{
	local first_option all_short_options='vlrmidsupth'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_version="off"
_arg_link="off"
_arg_reset="off"
_arg_debug="off"
_arg_update_method=
_arg_ip_mode=
_arg_domain=
_arg_service_provider=
_arg_username=
_arg_password=
_arg_token=
_arg_interval=


# Function that prints general usage of the script.
# This is useful if users asks for it, or if there is an argument parsing error (unexpected / spurious arguments)
# and it makes sense to remind the user how the script is supposed to be called.
print_help()
{
	printf '%s\n' "DynB - dynamic DNS update script for bash"
	printf 'Usage: %s [-v|--(no-)version] [-l|--(no-)link] [-r|--(no-)reset] [--(no-)debug] [-m|--update-method <arg>] [-i|--ip-mode <arg>] [-d|--domain <arg>] [-s|--service-provider <arg>] [-u|--username <arg>] [-p|--password <arg>] [-t|--token <arg>] [--interval <arg>] [-h|--help]\n' "$0"
	printf '\t%s\n' "-v, --version, --no-version: outputs the client version (off by default)"
	printf '\t%s\n' "-l, --link, --no-link: links to your script at ~/.local/bin/dynb (off by default)"
	printf '\t%s\n' "-r, --reset, --no-reset: deletes the client blocking status file (off by default)"
	printf '\t%s\n' "--debug, --no-debug: enables debug mode (off by default)"
	printf '\t%s\n' "-m, --update-method: choose if you want to use DynDNS2 or the DomRobot RPC-API (no default)"
	printf '\t%s\n' "-i, --ip-mode: updates type A (IPv4) and AAAA (IPv6) records (no default)"
	printf '\t%s\n' "-d, --domain: set the domain you want to update (no default)"
	printf '\t%s\n' "-s, --service-provider: set your provider in case you are using DynDNS2 (no default)"
	printf '\t%s\n' "-u, --username: depends on your selected update method and your provider (no default)"
	printf '\t%s\n' "-p, --password: depends on your selected update method and your provider (no default)"
	printf '\t%s\n' "-t, --token: depends on your selected update method and your provider (no default)"
	printf '\t%s\n' "--interval: choose the seconds interval to run the script in a loop, minimum is 60 (no default)"
	printf '\t%s\n' "-h, --help: Prints help"
}


# The parsing of the command-line
parse_commandline()
{
	while test $# -gt 0
	do
		_key="$1"
		case "$_key" in
			# The version argurment doesn't accept a value,
			# we expect the --version or -v, so we watch for them.
			-v|--no-version|--version)
				_arg_version="on"
				test "${1:0:5}" = "--no-" && _arg_version="off"
				;;
			# We support getopts-style short arguments clustering,
			# so as -v doesn't accept value, other short options may be appended to it, so we watch for -v*.
			# After stripping the leading -v from the argument, we have to make sure
			# that the first character that follows coresponds to a short option.
			-v*)
				_arg_version="on"
				_next="${_key##-v}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					{ begins_with_short_option "$_next" && shift && set -- "-v" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			# See the comment of option '--version' to see what's going on here - principle is the same.
			-l|--no-link|--link)
				_arg_link="on"
				test "${1:0:5}" = "--no-" && _arg_link="off"
				;;
			# See the comment of option '-v' to see what's going on here - principle is the same.
			-l*)
				_arg_link="on"
				_next="${_key##-l}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					{ begins_with_short_option "$_next" && shift && set -- "-l" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			# See the comment of option '--version' to see what's going on here - principle is the same.
			-r|--no-reset|--reset)
				_arg_reset="on"
				test "${1:0:5}" = "--no-" && _arg_reset="off"
				;;
			# See the comment of option '-v' to see what's going on here - principle is the same.
			-r*)
				_arg_reset="on"
				_next="${_key##-r}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					{ begins_with_short_option "$_next" && shift && set -- "-r" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			# See the comment of option '--version' to see what's going on here - principle is the same.
			--no-debug|--debug)
				_arg_debug="on"
				test "${1:0:5}" = "--no-" && _arg_debug="off"
				;;
			# We support whitespace as a delimiter between option argument and its value.
			# Therefore, we expect the --update-method or -m value.
			# so we watch for --update-method and -m.
			# Since we know that we got the long or short option,
			# we just reach out for the next argument to get the value.
			-m|--update-method)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_update_method="$2"
				shift
				;;
			# We support the = as a delimiter between option argument and its value.
			# Therefore, we expect --update-method=value, so we watch for --update-method=*
			# For whatever we get, we strip '--update-method=' using the ${var##--update-method=} notation
			# to get the argument value
			--update-method=*)
				_arg_update_method="${_key##--update-method=}"
				;;
			# We support getopts-style short arguments grouping,
			# so as -m accepts value, we allow it to be appended to it, so we watch for -m*
			# and we strip the leading -m from the argument string using the ${var##-m} notation.
			-m*)
				_arg_update_method="${_key##-m}"
				;;
			# See the comment of option '--update-method' to see what's going on here - principle is the same.
			-i|--ip-mode)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_ip_mode="$2"
				shift
				;;
			# See the comment of option '--update-method=' to see what's going on here - principle is the same.
			--ip-mode=*)
				_arg_ip_mode="${_key##--ip-mode=}"
				;;
			# See the comment of option '-m' to see what's going on here - principle is the same.
			-i*)
				_arg_ip_mode="${_key##-i}"
				;;
			# See the comment of option '--update-method' to see what's going on here - principle is the same.
			-d|--domain)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_domain="$2"
				shift
				;;
			# See the comment of option '--update-method=' to see what's going on here - principle is the same.
			--domain=*)
				_arg_domain="${_key##--domain=}"
				;;
			# See the comment of option '-m' to see what's going on here - principle is the same.
			-d*)
				_arg_domain="${_key##-d}"
				;;
			# See the comment of option '--update-method' to see what's going on here - principle is the same.
			-s|--service-provider)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_service_provider="$2"
				shift
				;;
			# See the comment of option '--update-method=' to see what's going on here - principle is the same.
			--service-provider=*)
				_arg_service_provider="${_key##--service-provider=}"
				;;
			# See the comment of option '-m' to see what's going on here - principle is the same.
			-s*)
				_arg_service_provider="${_key##-s}"
				;;
			# See the comment of option '--update-method' to see what's going on here - principle is the same.
			-u|--username)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_username="$2"
				shift
				;;
			# See the comment of option '--update-method=' to see what's going on here - principle is the same.
			--username=*)
				_arg_username="${_key##--username=}"
				;;
			# See the comment of option '-m' to see what's going on here - principle is the same.
			-u*)
				_arg_username="${_key##-u}"
				;;
			# See the comment of option '--update-method' to see what's going on here - principle is the same.
			-p|--password)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_password="$2"
				shift
				;;
			# See the comment of option '--update-method=' to see what's going on here - principle is the same.
			--password=*)
				_arg_password="${_key##--password=}"
				;;
			# See the comment of option '-m' to see what's going on here - principle is the same.
			-p*)
				_arg_password="${_key##-p}"
				;;
			# See the comment of option '--update-method' to see what's going on here - principle is the same.
			-t|--token)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_token="$2"
				shift
				;;
			# See the comment of option '--update-method=' to see what's going on here - principle is the same.
			--token=*)
				_arg_token="${_key##--token=}"
				;;
			# See the comment of option '-m' to see what's going on here - principle is the same.
			-t*)
				_arg_token="${_key##-t}"
				;;
			# See the comment of option '--update-method' to see what's going on here - principle is the same.
			--interval)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_interval="$2"
				shift
				;;
			# See the comment of option '--update-method=' to see what's going on here - principle is the same.
			--interval=*)
				_arg_interval="${_key##--interval=}"
				;;
			# See the comment of option '--version' to see what's going on here - principle is the same.
			-h|--help)
				print_help
				exit 0
				;;
			# See the comment of option '-v' to see what's going on here - principle is the same.
			-h*)
				print_help
				exit 0
				;;
			*)
				_PRINT_HELP=yes die "FATAL ERROR: Got an unexpected argument '$1'" 1
				;;
		esac
		shift
	done
}

# Now call all the functions defined above that are needed to get the job done
parse_commandline "$@"

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash


# vvv  PLACE YOUR CODE HERE  vvv

# PUT YOUR CODE HERE

# ^^^  TERMINATE YOUR CODE BEFORE THE BOTTOM ARGBASH MARKER  ^^^

# ] <-- needed because of Argbash
